#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (C) 2007 - 2011 Canonical Ltd.
# Copyright (C) 2014 Zentyal S.L.
# Author: Based on Martin Pitt <martin.pitt@ubuntu.com> work
# Author: Enrique J. Hern√°ndez <ejhernandez@zentyal.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See http://www.gnu.org/copyleft/gpl.html for
# the full text of the license.

#
# This is an enhancement version of crash-digger available with apport-retrace
#

import errno
import optparse
import os
import shutil
import subprocess
import sys
import time
import zlib


import apport
from apport.crashdb import get_crashdb
from problem_report import ProblemReport


#
# classes
#
class CrashDigger(object):
    def __init__(self, config_dir, cache_dir, apport_retrace,
                 verbose=False, dup_db=None, dupcheck_mode=False, publish_dir=None,
                 crashes_dir=None, oc_cd_conf=None):
        """
        Initialize pools.

        :param str crashes_dir: the directory to collect crashes from
        :param str oc_cd_conf: the configuration file with specific options for this digger
        """
        self.retrace_pool = set()
        self.dupcheck_pool = set()
        self.config_dir = config_dir
        self.cache_dir = cache_dir
        self.verbose = verbose
        self.dup_db = dup_db
        self.dupcheck_mode = dupcheck_mode
        self.crashdb = get_crashdb(None)
        self.apport_retrace = apport_retrace
        self.publish_dir = publish_dir
        self.crashes_dir = crashes_dir
        self.crashes_files = dict()
        self.oc_cd_conf = oc_cd_conf
        if config_dir:
            self.releases = os.listdir(config_dir)
            self.releases.sort()
            self.log('Available releases: %s' % str(self.releases))
        else:
            self.releases = None

        if self.dup_db:
            self.crashdb.init_duplicate_db(self.dup_db)
            # this verified DB integrity; make a backup now
            shutil.copy2(self.dup_db, self.dup_db + '.backup')

        if self.oc_cd_conf:
            oc_cd_conf_settings = dict()
            with open(self.oc_cd_conf) as f:
                exec(compile(f.read(), self.oc_cd_conf, 'exec'), oc_cd_conf_settings)
                self.oc_cd_conf = {'extra_packages': oc_cd_conf_settings['extra_packages']}

    def log(self, str):
        """
        If verbosity is enabled, log the given string to stdout, and prepend
        the current date and time.
        """
        sys.stdout.write('%s: %s\n' % (time.strftime('%x %X'), str))
        sys.stdout.flush()

    def fill_pool(self):
        """
        Query crash db for new IDs to process.
        """
        if self.dupcheck_mode:
            self.dupcheck_pool.update(self.crashdb.get_dup_unchecked())
            self.log('fill_pool: dup check pool now: %s' % str(self.dupcheck_pool))
        else:
            if self.crashes_dir:
                self.fill_crashdb()
            self.retrace_pool.update(self.crashdb.get_unretraced())
            self.log('fill_pool: retrace pool now: %s' % str(self.retrace_pool))

    def fill_crashdb(self):
        """
        Go through crashes directory and load into crashdb
        """
        if not os.path.isdir(self.crashes_dir):
            raise SystemError("%s is not a directory" % self.crashes_dir)

        for fname in os.listdir(self.crashes_dir):
            fpath = os.path.join(self.crashes_dir, fname)
            with open(fpath, 'rb') as f:
                try:
                    report = ProblemReport(f)
                    report.load(f)
                    report_id = self.crashdb.upload(report)
                    self.crashes_files[report_id] = fpath
                    self.log('%s uploaded.' % fpath)
                except Exception as exc:
                    self.log("Cannot load %s: %s" % (fpath, exc))

    def retrace_next(self):
        """
        Grab an ID from the retrace pool and retrace it.
        """

        id = self.retrace_pool.pop()
        self.log('retracing #%i (left in pool: %i)' % (id, len(self.retrace_pool)))

        try:
            rel = self.crashdb.get_distro_release(id)
        except ValueError:
            self.log('could not determine release -- no DistroRelease field?')
            self.crashdb.mark_retraced(id)
            return
        if rel not in self.releases:
            self.log('crash is release %s which does not have a config available, skipping' % rel)
            return

        argv = [self.apport_retrace, '-S', self.config_dir, '--timestamps']
        if self.cache_dir:
            argv += ['--cache', self.cache_dir]
        if self.dup_db:
            argv += ['--duplicate-db', self.dup_db]
        if self.verbose:
            argv.append('-v')

        if self.crashes_dir and id in self.crashes_files:
            argv.append('-s')  # Put in stdout by now
            if self.oc_cd_conf and 'extra_packages' in self.oc_cd_conf:
                for package in self.oc_cd_conf['extra_packages']:
                    argv.extend(['--extra-package', package])
            argv.append(self.crashes_files[id])
        else:
            argv.append(str(id))

        self.log(' '.join(argv))
        result = subprocess.call(argv, stdout=sys.stdout,
                                 stderr=subprocess.STDOUT)
        if result != 0:
            self.log('retracing #%i failed with status: %i' % (id, result))
            if result == 99:
                self.retrace_pool = set()
                self.log('transient error reported; halting')
                return
            raise SystemError('retracing #%i failed' % id)

        self.crashdb.mark_retraced(id)

    def dupcheck_next(self):
        """
        Grab an ID from the dupcheck pool and process it.
        """

        id = self.dupcheck_pool.pop()
        self.log('checking #%i for duplicate (left in pool: %i)' % (id, len(self.dupcheck_pool)))

        try:
            report = self.crashdb.download(id)
        except (MemoryError, TypeError, ValueError, IOError, zlib.error) as e:
            self.log('Cannot download report: ' + str(e))
            apport.error('Cannot download report %i: %s', id, str(e))
            return

        res = self.crashdb.check_duplicate(id, report)
        if res:
            if res[1] is None:
                self.log('Report is a duplicate of #%i (not fixed yet)' % res[0])
            elif res[1] == '':
                self.log('Report is a duplicate of #%i (fixed in latest version)' % res[0])
            else:
                self.log('Report is a duplicate of #%i (fixed in version %s)' % res)
        else:
            self.log('Duplicate check negative')

    def run(self):
        """
        Process the work pools until they are empty.
        """

        self.fill_pool()
        while self.dupcheck_pool:
            self.dupcheck_next()
        while self.retrace_pool:
            self.retrace_next()

        if self.publish_dir and self.dup_db:
            self.crashdb.duplicate_db_publish(self.publish_dir)


#
# functions
#
def parse_options():
    """
    Parse command line options and return (options, args) tuple.
    """

    optparser = optparse.OptionParser('%prog [options]')
    optparser.add_option('-c', '--config-dir', metavar='DIR',
                         help='Packaging system configuration base directory.')
    optparser.add_option('-C', '--cache', metavar='DIR',
                         help='Cache directory for packages downloaded in the sandbox')
    optparser.add_option('-l', '--lock',
                         help='Lock file; will be created and removed on successful exit, and '
                         'program immediately aborts if it already exists',
                         action='store', dest='lockfile', default=None)
    optparser.add_option('-d', '--duplicate-db',
                         help='Path to the duplicate sqlite database (default: disabled)',
                         action='store', type='string', dest='dup_db', metavar='PATH',
                         default=None)
    optparser.add_option('-D', '--dupcheck',
                         help='Only check duplicates for architecture independent crashes (like Python exceptions)',
                         action='store_true', dest='dupcheck_mode', default=False)
    optparser.add_option('-v', '--verbose',
                         help='Verbose operation (also passed to apport-retrace)',
                         action='store_true', dest='verbose', default=False)
    optparser.add_option('--apport-retrace', metavar='PATH',
                         help='Path to apport-retrace script (default: directory of crash-digger or $PATH)')
    optparser.add_option('--publish-db',
                         help='After processing all reports, publish duplicate database to given directory',
                         metavar='DIR', default=None)
    # OC crash digger specific options
    optparser.add_option('-S', '--crashes', metavar='DIR',
                         help="Directory to look for crashes to fill")
    optparser.add_option('-O', '--oc-cd-conf', metavar='FILE',
                         help='oc-crash-digger specific configuration')

    (opts, args) = optparser.parse_args()

    if not opts.config_dir and not opts.dupcheck_mode:
        apport.fatal('Error: --config-dir or --dupcheck needs to be given')

    return (opts, args)


#
# main
#
opts, args = parse_options()


# support running from tree, then fall back to $PATH
if not opts.apport_retrace:
    opts.apport_retrace = os.path.join(os.path.dirname(sys.argv[0]),
                                       'apport-retrace')
    if not os.access(opts.apport_retrace, os.X_OK):
        opts.apport_retrace = 'apport-retrace'

if opts.lockfile:
    try:
        f = os.open(opts.lockfile, os.O_WRONLY | os.O_CREAT | os.O_EXCL, 0o666)
        os.close(f)
    except OSError as e:
        if e.errno == errno.EEXIST:
            sys.exit(0)
        else:
            raise

try:
    CrashDigger(opts.config_dir, opts.cache,
                opts.apport_retrace, opts.verbose, opts.dup_db,
                opts.dupcheck_mode, opts.publish_db, opts.crashes,
                opts.oc_cd_conf).run()
except SystemExit as exit:
    if exit.code == 99:
        pass  # fall through lock cleanup
    else:
        raise

if opts.lockfile:
    os.unlink(opts.lockfile)
